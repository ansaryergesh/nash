self["webpackHotUpdate_N_E"]("pages/feedback",{

/***/ "./components/feedback/Feedback.js":
/*!*****************************************!*\
  !*** ./components/feedback/Feedback.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var E_job_nashcompany_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_input_mask__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-input-mask */ "./node_modules/react-input-mask/index.js");
/* harmony import */ var react_input_mask__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_input_mask__WEBPACK_IMPORTED_MODULE_3__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "E:\\job\\nashcompany\\components\\feedback\\Feedback.js",
    _this = undefined,
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,E_job_nashcompany_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var FeedbackForm = function FeedbackForm() {
  _s();

  var _jsxDEV2;

  var getPhone = function getPhone(value) {
    var defaultMask = "+7(999)-999-9999";
    return defaultMask;
  };

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({
    value: '',
    mask: getPhone()
  }),
      items = _useState[0],
      setItems = _useState[1];

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("div", {
    className: "form_register",
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("form", {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("input", {
        type: "text",
        className: "capitalize",
        placeholder: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)((react_input_mask__WEBPACK_IMPORTED_MODULE_3___default()), _objectSpread(_objectSpread(_objectSpread({}, items), {}, {
        maskChar: null,
        className: "my-input"
      }, field), props), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 17,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("textarea", {
        placeholder: "\u041E\u0442\u0437\u044B\u0432"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("input", (_jsxDEV2 = {
        className: "singlebtn",
        type: "submit"
      }, (0,E_job_nashcompany_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_jsxDEV2, "className", "button"), (0,E_job_nashcompany_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(_jsxDEV2, "value", "\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C"), _jsxDEV2), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 24,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 5
  }, _this);
};

_s(FeedbackForm, "/ag2wCkC71hC+JBrV2pqnhHVbIY=");

_c = FeedbackForm;
/* harmony default export */ __webpack_exports__["default"] = (FeedbackForm);

var _c;

$RefreshReg$(_c, "FeedbackForm");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "./node_modules/react-input-mask/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-input-mask/index.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

if (false) {} else {
  module.exports = __webpack_require__(/*! ./lib/react-input-mask.development.js */ "./node_modules/react-input-mask/lib/react-input-mask.development.js");
}


/***/ }),

/***/ "./node_modules/react-input-mask/lib/react-input-mask.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-input-mask/lib/react-input-mask.development.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var reactDom = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
var invariant = _interopDefault(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var warning = _interopDefault(__webpack_require__(/*! warning */ "./node_modules/warning/warning.js"));

function _defaults2(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _defaults2(subClass, superClass);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function setInputSelection(input, start, end) {
  if ('selectionStart' in input && 'selectionEnd' in input) {
    input.selectionStart = start;
    input.selectionEnd = end;
  } else {
    var range = input.createTextRange();
    range.collapse(true);
    range.moveStart('character', start);
    range.moveEnd('character', end - start);
    range.select();
  }
}
function getInputSelection(input) {
  var start = 0;
  var end = 0;

  if ('selectionStart' in input && 'selectionEnd' in input) {
    start = input.selectionStart;
    end = input.selectionEnd;
  } else {
    var range = document.selection.createRange();

    if (range.parentElement() === input) {
      start = -range.moveStart('character', -input.value.length);
      end = -range.moveEnd('character', -input.value.length);
    }
  }

  return {
    start: start,
    end: end,
    length: end - start
  };
}

var defaultFormatChars = {
  '9': '[0-9]',
  'a': '[A-Za-z]',
  '*': '[A-Za-z0-9]'
};
var defaultMaskChar = '_';

function parseMask (mask, maskChar, formatChars) {
  var parsedMaskString = '';
  var prefix = '';
  var lastEditablePosition = null;
  var permanents = [];

  if (maskChar === undefined) {
    maskChar = defaultMaskChar;
  }

  if (formatChars == null) {
    formatChars = defaultFormatChars;
  }

  if (!mask || typeof mask !== 'string') {
    return {
      maskChar: maskChar,
      formatChars: formatChars,
      mask: null,
      prefix: null,
      lastEditablePosition: null,
      permanents: []
    };
  }

  var isPermanent = false;
  mask.split('').forEach(function (character) {
    if (!isPermanent && character === '\\') {
      isPermanent = true;
    } else {
      if (isPermanent || !formatChars[character]) {
        permanents.push(parsedMaskString.length);

        if (parsedMaskString.length === permanents.length - 1) {
          prefix += character;
        }
      } else {
        lastEditablePosition = parsedMaskString.length + 1;
      }

      parsedMaskString += character;
      isPermanent = false;
    }
  });
  return {
    maskChar: maskChar,
    formatChars: formatChars,
    prefix: prefix,
    mask: parsedMaskString,
    lastEditablePosition: lastEditablePosition,
    permanents: permanents
  };
}

/* eslint no-use-before-define: ["error", { functions: false }] */
function isPermanentCharacter(maskOptions, pos) {
  return maskOptions.permanents.indexOf(pos) !== -1;
}
function isAllowedCharacter(maskOptions, pos, character) {
  var mask = maskOptions.mask,
      formatChars = maskOptions.formatChars;

  if (!character) {
    return false;
  }

  if (isPermanentCharacter(maskOptions, pos)) {
    return mask[pos] === character;
  }

  var ruleChar = mask[pos];
  var charRule = formatChars[ruleChar];
  return new RegExp(charRule).test(character);
}
function isEmpty(maskOptions, value) {
  return value.split('').every(function (character, i) {
    return isPermanentCharacter(maskOptions, i) || !isAllowedCharacter(maskOptions, i, character);
  });
}
function getFilledLength(maskOptions, value) {
  var maskChar = maskOptions.maskChar,
      prefix = maskOptions.prefix;

  if (!maskChar) {
    while (value.length > prefix.length && isPermanentCharacter(maskOptions, value.length - 1)) {
      value = value.slice(0, value.length - 1);
    }

    return value.length;
  }

  var filledLength = prefix.length;

  for (var i = value.length; i >= prefix.length; i--) {
    var character = value[i];
    var isEnteredCharacter = !isPermanentCharacter(maskOptions, i) && isAllowedCharacter(maskOptions, i, character);

    if (isEnteredCharacter) {
      filledLength = i + 1;
      break;
    }
  }

  return filledLength;
}
function isFilled(maskOptions, value) {
  return getFilledLength(maskOptions, value) === maskOptions.mask.length;
}
function formatValue(maskOptions, value) {
  var maskChar = maskOptions.maskChar,
      mask = maskOptions.mask,
      prefix = maskOptions.prefix;

  if (!maskChar) {
    value = insertString(maskOptions, '', value, 0);

    if (value.length < prefix.length) {
      value = prefix;
    }

    while (value.length < mask.length && isPermanentCharacter(maskOptions, value.length)) {
      value += mask[value.length];
    }

    return value;
  }

  if (value) {
    var emptyValue = formatValue(maskOptions, '');
    return insertString(maskOptions, emptyValue, value, 0);
  }

  for (var i = 0; i < mask.length; i++) {
    if (isPermanentCharacter(maskOptions, i)) {
      value += mask[i];
    } else {
      value += maskChar;
    }
  }

  return value;
}
function clearRange(maskOptions, value, start, len) {
  var end = start + len;
  var maskChar = maskOptions.maskChar,
      mask = maskOptions.mask,
      prefix = maskOptions.prefix;
  var arrayValue = value.split('');

  if (!maskChar) {
    // remove any permanent chars after clear range, they will be added back by formatValue
    for (var i = end; i < arrayValue.length; i++) {
      if (isPermanentCharacter(maskOptions, i)) {
        arrayValue[i] = '';
      }
    }

    start = Math.max(prefix.length, start);
    arrayValue.splice(start, end - start);
    value = arrayValue.join('');
    return formatValue(maskOptions, value);
  }

  return arrayValue.map(function (character, i) {
    if (i < start || i >= end) {
      return character;
    }

    if (isPermanentCharacter(maskOptions, i)) {
      return mask[i];
    }

    return maskChar;
  }).join('');
}
function insertString(maskOptions, value, insertStr, insertPosition) {
  var mask = maskOptions.mask,
      maskChar = maskOptions.maskChar,
      prefix = maskOptions.prefix;
  var arrayInsertStr = insertStr.split('');
  var isInputFilled = isFilled(maskOptions, value);

  var isUsablePosition = function isUsablePosition(pos, character) {
    return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];
  };

  var isUsableCharacter = function isUsableCharacter(character, pos) {
    return !maskChar || !isPermanentCharacter(maskOptions, pos) || character !== maskChar;
  };

  if (!maskChar && insertPosition > value.length) {
    value += mask.slice(value.length, insertPosition);
  }

  arrayInsertStr.every(function (insertCharacter) {
    while (!isUsablePosition(insertPosition, insertCharacter)) {
      if (insertPosition >= value.length) {
        value += mask[insertPosition];
      }

      if (!isUsableCharacter(insertCharacter, insertPosition)) {
        return true;
      }

      insertPosition++; // stop iteration if maximum value length reached

      if (insertPosition >= mask.length) {
        return false;
      }
    }

    var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;

    if (!isAllowed) {
      return true;
    }

    if (insertPosition < value.length) {
      if (maskChar || isInputFilled || insertPosition < prefix.length) {
        value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition + 1);
      } else {
        value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition);
        value = formatValue(maskOptions, value);
      }
    } else if (!maskChar) {
      value += insertCharacter;
    }

    insertPosition++; // stop iteration if maximum value length reached

    return insertPosition < mask.length;
  });
  return value;
}
function getInsertStringLength(maskOptions, value, insertStr, insertPosition) {
  var mask = maskOptions.mask,
      maskChar = maskOptions.maskChar;
  var arrayInsertStr = insertStr.split('');
  var initialInsertPosition = insertPosition;

  var isUsablePosition = function isUsablePosition(pos, character) {
    return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];
  };

  arrayInsertStr.every(function (insertCharacter) {
    while (!isUsablePosition(insertPosition, insertCharacter)) {
      insertPosition++; // stop iteration if maximum value length reached

      if (insertPosition >= mask.length) {
        return false;
      }
    }

    var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;

    if (isAllowed) {
      insertPosition++;
    } // stop iteration if maximum value length reached


    return insertPosition < mask.length;
  });
  return insertPosition - initialInsertPosition;
}
function getLeftEditablePosition(maskOptions, pos) {
  for (var i = pos; i >= 0; --i) {
    if (!isPermanentCharacter(maskOptions, i)) {
      return i;
    }
  }

  return null;
}
function getRightEditablePosition(maskOptions, pos) {
  var mask = maskOptions.mask;

  for (var i = pos; i < mask.length; ++i) {
    if (!isPermanentCharacter(maskOptions, i)) {
      return i;
    }
  }

  return null;
}
function getStringValue(value) {
  return !value && value !== 0 ? '' : value + '';
}

function processChange(maskOptions, value, selection, previousValue, previousSelection) {
  var mask = maskOptions.mask,
      prefix = maskOptions.prefix,
      lastEditablePosition = maskOptions.lastEditablePosition;
  var newValue = value;
  var enteredString = '';
  var formattedEnteredStringLength = 0;
  var removedLength = 0;
  var cursorPosition = Math.min(previousSelection.start, selection.start);

  if (selection.end > previousSelection.start) {
    enteredString = newValue.slice(previousSelection.start, selection.end);
    formattedEnteredStringLength = getInsertStringLength(maskOptions, previousValue, enteredString, cursorPosition);

    if (!formattedEnteredStringLength) {
      removedLength = 0;
    } else {
      removedLength = previousSelection.length;
    }
  } else if (newValue.length < previousValue.length) {
    removedLength = previousValue.length - newValue.length;
  }

  newValue = previousValue;

  if (removedLength) {
    if (removedLength === 1 && !previousSelection.length) {
      var deleteFromRight = previousSelection.start === selection.start;
      cursorPosition = deleteFromRight ? getRightEditablePosition(maskOptions, selection.start) : getLeftEditablePosition(maskOptions, selection.start);
    }

    newValue = clearRange(maskOptions, newValue, cursorPosition, removedLength);
  }

  newValue = insertString(maskOptions, newValue, enteredString, cursorPosition);
  cursorPosition = cursorPosition + formattedEnteredStringLength;

  if (cursorPosition >= mask.length) {
    cursorPosition = mask.length;
  } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {
    cursorPosition = prefix.length;
  } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {
    cursorPosition = getRightEditablePosition(maskOptions, cursorPosition);
  }

  newValue = formatValue(maskOptions, newValue);

  if (!enteredString) {
    enteredString = null;
  }

  return {
    value: newValue,
    enteredString: enteredString,
    selection: {
      start: cursorPosition,
      end: cursorPosition
    }
  };
}

function isWindowsPhoneBrowser() {
  var windows = new RegExp('windows', 'i');
  var phone = new RegExp('phone', 'i');
  var ua = navigator.userAgent;
  return windows.test(ua) && phone.test(ua);
}

function isFunction(value) {
  return typeof value === 'function';
}

function getRequestAnimationFrame() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
}

function getCancelAnimationFrame() {
  return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;
}

function defer(fn) {
  var hasCancelAnimationFrame = !!getCancelAnimationFrame();
  var deferFn;

  if (hasCancelAnimationFrame) {
    deferFn = getRequestAnimationFrame();
  } else {
    deferFn = function deferFn() {
      return setTimeout(fn, 1000 / 60);
    };
  }

  return deferFn(fn);
}
function cancelDefer(deferId) {
  var cancelFn = getCancelAnimationFrame() || clearTimeout;
  cancelFn(deferId);
}

var InputElement =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InputElement, _React$Component);

  function InputElement(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.focused = false;
    _this.mounted = false;
    _this.previousSelection = null;
    _this.selectionDeferId = null;
    _this.saveSelectionLoopDeferId = null;

    _this.saveSelectionLoop = function () {
      _this.previousSelection = _this.getSelection();
      _this.saveSelectionLoopDeferId = defer(_this.saveSelectionLoop);
    };

    _this.runSaveSelectionLoop = function () {
      if (_this.saveSelectionLoopDeferId === null) {
        _this.saveSelectionLoop();
      }
    };

    _this.stopSaveSelectionLoop = function () {
      if (_this.saveSelectionLoopDeferId !== null) {
        cancelDefer(_this.saveSelectionLoopDeferId);
        _this.saveSelectionLoopDeferId = null;
        _this.previousSelection = null;
      }
    };

    _this.getInputDOMNode = function () {
      if (!_this.mounted) {
        return null;
      }

      var input = reactDom.findDOMNode(_assertThisInitialized(_assertThisInitialized(_this)));
      var isDOMNode = typeof window !== 'undefined' && input instanceof window.Element; // workaround for react-test-renderer
      // https://github.com/sanniassin/react-input-mask/issues/147

      if (input && !isDOMNode) {
        return null;
      }

      if (input.nodeName !== 'INPUT') {
        input = input.querySelector('input');
      }

      if (!input) {
        throw new Error('react-input-mask: inputComponent doesn\'t contain input node');
      }

      return input;
    };

    _this.getInputValue = function () {
      var input = _this.getInputDOMNode();

      if (!input) {
        return null;
      }

      return input.value;
    };

    _this.setInputValue = function (value) {
      var input = _this.getInputDOMNode();

      if (!input) {
        return;
      }

      _this.value = value;
      input.value = value;
    };

    _this.setCursorToEnd = function () {
      var filledLength = getFilledLength(_this.maskOptions, _this.value);
      var pos = getRightEditablePosition(_this.maskOptions, filledLength);

      if (pos !== null) {
        _this.setCursorPosition(pos);
      }
    };

    _this.setSelection = function (start, end, options) {
      if (options === void 0) {
        options = {};
      }

      var input = _this.getInputDOMNode();

      var isFocused = _this.isFocused(); // don't change selection on unfocused input
      // because Safari sets focus on selection change (#154)


      if (!input || !isFocused) {
        return;
      }

      var _options = options,
          deferred = _options.deferred;

      if (!deferred) {
        setInputSelection(input, start, end);
      }

      if (_this.selectionDeferId !== null) {
        cancelDefer(_this.selectionDeferId);
      } // deferred selection update is required for pre-Lollipop Android browser,
      // but for consistent behavior we do it for all browsers


      _this.selectionDeferId = defer(function () {
        _this.selectionDeferId = null;
        setInputSelection(input, start, end);
      });
      _this.previousSelection = {
        start: start,
        end: end,
        length: Math.abs(end - start)
      };
    };

    _this.getSelection = function () {
      var input = _this.getInputDOMNode();

      return getInputSelection(input);
    };

    _this.getCursorPosition = function () {
      return _this.getSelection().start;
    };

    _this.setCursorPosition = function (pos) {
      _this.setSelection(pos, pos);
    };

    _this.isFocused = function () {
      return _this.focused;
    };

    _this.getBeforeMaskedValueChangeConfig = function () {
      var _this$maskOptions = _this.maskOptions,
          mask = _this$maskOptions.mask,
          maskChar = _this$maskOptions.maskChar,
          permanents = _this$maskOptions.permanents,
          formatChars = _this$maskOptions.formatChars;
      var alwaysShowMask = _this.props.alwaysShowMask;
      return {
        mask: mask,
        maskChar: maskChar,
        permanents: permanents,
        alwaysShowMask: !!alwaysShowMask,
        formatChars: formatChars
      };
    };

    _this.isInputAutofilled = function (value, selection, previousValue, previousSelection) {
      var input = _this.getInputDOMNode(); // only check for positive match because it will be false negative
      // in case of autofill simulation in tests
      //
      // input.matches throws an exception if selector isn't supported


      try {
        if (input.matches(':-webkit-autofill')) {
          return true;
        }
      } catch (e) {} // if input isn't focused then change event must have been triggered
      // either by autofill or event simulation in tests


      if (!_this.focused) {
        return true;
      } // if cursor has moved to the end while previousSelection forbids it
      // then it must be autofill


      return previousSelection.end < previousValue.length && selection.end === value.length;
    };

    _this.onChange = function (event) {
      var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),
          beforePasteState = _assertThisInitialize.beforePasteState;

      var _assertThisInitialize2 = _assertThisInitialized(_assertThisInitialized(_this)),
          previousSelection = _assertThisInitialize2.previousSelection;

      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;

      var value = _this.getInputValue();

      var previousValue = _this.value;

      var selection = _this.getSelection(); // autofill replaces entire value, ignore old one
      // https://github.com/sanniassin/react-input-mask/issues/113


      if (_this.isInputAutofilled(value, selection, previousValue, previousSelection)) {
        previousValue = formatValue(_this.maskOptions, '');
        previousSelection = {
          start: 0,
          end: 0,
          length: 0
        };
      } // set value and selection as if we haven't
      // cleared input in onPaste handler


      if (beforePasteState) {
        previousSelection = beforePasteState.selection;
        previousValue = beforePasteState.value;
        selection = {
          start: previousSelection.start + value.length,
          end: previousSelection.start + value.length,
          length: 0
        };
        value = previousValue.slice(0, previousSelection.start) + value + previousValue.slice(previousSelection.end);
        _this.beforePasteState = null;
      }

      var changedState = processChange(_this.maskOptions, value, selection, previousValue, previousSelection);
      var enteredString = changedState.enteredString;
      var newSelection = changedState.selection;
      var newValue = changedState.value;

      if (isFunction(beforeMaskedValueChange)) {
        var modifiedValue = beforeMaskedValueChange({
          value: newValue,
          selection: newSelection
        }, {
          value: previousValue,
          selection: previousSelection
        }, enteredString, _this.getBeforeMaskedValueChangeConfig());
        newValue = modifiedValue.value;
        newSelection = modifiedValue.selection;
      }

      _this.setInputValue(newValue);

      if (isFunction(_this.props.onChange)) {
        _this.props.onChange(event);
      }

      if (_this.isWindowsPhoneBrowser) {
        _this.setSelection(newSelection.start, newSelection.end, {
          deferred: true
        });
      } else {
        _this.setSelection(newSelection.start, newSelection.end);
      }
    };

    _this.onFocus = function (event) {
      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;
      var _this$maskOptions2 = _this.maskOptions,
          mask = _this$maskOptions2.mask,
          prefix = _this$maskOptions2.prefix;
      _this.focused = true; // if autoFocus is set, onFocus triggers before componentDidMount

      _this.mounted = true;

      if (mask) {
        if (!_this.value) {
          var emptyValue = formatValue(_this.maskOptions, prefix);
          var newValue = formatValue(_this.maskOptions, emptyValue);
          var filledLength = getFilledLength(_this.maskOptions, newValue);
          var cursorPosition = getRightEditablePosition(_this.maskOptions, filledLength);
          var newSelection = {
            start: cursorPosition,
            end: cursorPosition
          };

          if (isFunction(beforeMaskedValueChange)) {
            var modifiedValue = beforeMaskedValueChange({
              value: newValue,
              selection: newSelection
            }, {
              value: _this.value,
              selection: null
            }, null, _this.getBeforeMaskedValueChangeConfig());
            newValue = modifiedValue.value;
            newSelection = modifiedValue.selection;
          }

          var isInputValueChanged = newValue !== _this.getInputValue();

          if (isInputValueChanged) {
            _this.setInputValue(newValue);
          }

          if (isInputValueChanged && isFunction(_this.props.onChange)) {
            _this.props.onChange(event);
          }

          _this.setSelection(newSelection.start, newSelection.end);
        } else if (getFilledLength(_this.maskOptions, _this.value) < _this.maskOptions.mask.length) {
          _this.setCursorToEnd();
        }

        _this.runSaveSelectionLoop();
      }

      if (isFunction(_this.props.onFocus)) {
        _this.props.onFocus(event);
      }
    };

    _this.onBlur = function (event) {
      var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;
      var mask = _this.maskOptions.mask;

      _this.stopSaveSelectionLoop();

      _this.focused = false;

      if (mask && !_this.props.alwaysShowMask && isEmpty(_this.maskOptions, _this.value)) {
        var newValue = '';

        if (isFunction(beforeMaskedValueChange)) {
          var modifiedValue = beforeMaskedValueChange({
            value: newValue,
            selection: null
          }, {
            value: _this.value,
            selection: _this.previousSelection
          }, null, _this.getBeforeMaskedValueChangeConfig());
          newValue = modifiedValue.value;
        }

        var isInputValueChanged = newValue !== _this.getInputValue();

        if (isInputValueChanged) {
          _this.setInputValue(newValue);
        }

        if (isInputValueChanged && isFunction(_this.props.onChange)) {
          _this.props.onChange(event);
        }
      }

      if (isFunction(_this.props.onBlur)) {
        _this.props.onBlur(event);
      }
    };

    _this.onMouseDown = function (event) {
      // tiny unintentional mouse movements can break cursor
      // position on focus, so we have to restore it in that case
      //
      // https://github.com/sanniassin/react-input-mask/issues/108
      if (!_this.focused && document.addEventListener) {
        _this.mouseDownX = event.clientX;
        _this.mouseDownY = event.clientY;
        _this.mouseDownTime = new Date().getTime();

        var mouseUpHandler = function mouseUpHandler(mouseUpEvent) {
          document.removeEventListener('mouseup', mouseUpHandler);

          if (!_this.focused) {
            return;
          }

          var deltaX = Math.abs(mouseUpEvent.clientX - _this.mouseDownX);
          var deltaY = Math.abs(mouseUpEvent.clientY - _this.mouseDownY);
          var axisDelta = Math.max(deltaX, deltaY);

          var timeDelta = new Date().getTime() - _this.mouseDownTime;

          if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {
            _this.setCursorToEnd();
          }
        };

        document.addEventListener('mouseup', mouseUpHandler);
      }

      if (isFunction(_this.props.onMouseDown)) {
        _this.props.onMouseDown(event);
      }
    };

    _this.onPaste = function (event) {
      if (isFunction(_this.props.onPaste)) {
        _this.props.onPaste(event);
      } // event.clipboardData might not work in Android browser
      // cleaning input to get raw text inside onChange handler


      if (!event.defaultPrevented) {
        _this.beforePasteState = {
          value: _this.getInputValue(),
          selection: _this.getSelection()
        };

        _this.setInputValue('');
      }
    };

    _this.handleRef = function (ref) {
      if (_this.props.children == null && isFunction(_this.props.inputRef)) {
        _this.props.inputRef(ref);
      }
    };

    var _mask = props.mask,
        _maskChar = props.maskChar,
        _formatChars = props.formatChars,
        _alwaysShowMask = props.alwaysShowMask,
        _beforeMaskedValueChange = props.beforeMaskedValueChange;
    var defaultValue = props.defaultValue,
        _value = props.value;
    _this.maskOptions = parseMask(_mask, _maskChar, _formatChars);

    if (defaultValue == null) {
      defaultValue = '';
    }

    if (_value == null) {
      _value = defaultValue;
    }

    var _newValue = getStringValue(_value);

    if (_this.maskOptions.mask && (_alwaysShowMask || _newValue)) {
      _newValue = formatValue(_this.maskOptions, _newValue);

      if (isFunction(_beforeMaskedValueChange)) {
        var oldValue = props.value;

        if (props.value == null) {
          oldValue = defaultValue;
        }

        oldValue = getStringValue(oldValue);

        var modifiedValue = _beforeMaskedValueChange({
          value: _newValue,
          selection: null
        }, {
          value: oldValue,
          selection: null
        }, null, _this.getBeforeMaskedValueChangeConfig());

        _newValue = modifiedValue.value;
      }
    }

    _this.value = _newValue;
    return _this;
  }

  var _proto = InputElement.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true; // workaround for react-test-renderer
    // https://github.com/sanniassin/react-input-mask/issues/147

    if (!this.getInputDOMNode()) {
      return;
    }

    this.isWindowsPhoneBrowser = isWindowsPhoneBrowser();

    if (this.maskOptions.mask && this.getInputValue() !== this.value) {
      this.setInputValue(this.value);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    var previousSelection = this.previousSelection;
    var _this$props = this.props,
        beforeMaskedValueChange = _this$props.beforeMaskedValueChange,
        alwaysShowMask = _this$props.alwaysShowMask,
        mask = _this$props.mask,
        maskChar = _this$props.maskChar,
        formatChars = _this$props.formatChars;
    var previousMaskOptions = this.maskOptions;
    var showEmpty = alwaysShowMask || this.isFocused();
    var hasValue = this.props.value != null;
    var newValue = hasValue ? getStringValue(this.props.value) : this.value;
    var cursorPosition = previousSelection ? previousSelection.start : null;
    this.maskOptions = parseMask(mask, maskChar, formatChars);

    if (!this.maskOptions.mask) {
      if (previousMaskOptions.mask) {
        this.stopSaveSelectionLoop(); // render depends on this.maskOptions and this.value,
        // call forceUpdate to keep it in sync

        this.forceUpdate();
      }

      return;
    } else if (!previousMaskOptions.mask && this.isFocused()) {
      this.runSaveSelectionLoop();
    }

    var isMaskChanged = this.maskOptions.mask && this.maskOptions.mask !== previousMaskOptions.mask;

    if (!previousMaskOptions.mask && !hasValue) {
      newValue = this.getInputValue();
    }

    if (isMaskChanged || this.maskOptions.mask && (newValue || showEmpty)) {
      newValue = formatValue(this.maskOptions, newValue);
    }

    if (isMaskChanged) {
      var filledLength = getFilledLength(this.maskOptions, newValue);

      if (cursorPosition === null || filledLength < cursorPosition) {
        if (isFilled(this.maskOptions, newValue)) {
          cursorPosition = filledLength;
        } else {
          cursorPosition = getRightEditablePosition(this.maskOptions, filledLength);
        }
      }
    }

    if (this.maskOptions.mask && isEmpty(this.maskOptions, newValue) && !showEmpty && (!hasValue || !this.props.value)) {
      newValue = '';
    }

    var newSelection = {
      start: cursorPosition,
      end: cursorPosition
    };

    if (isFunction(beforeMaskedValueChange)) {
      var modifiedValue = beforeMaskedValueChange({
        value: newValue,
        selection: newSelection
      }, {
        value: this.value,
        selection: this.previousSelection
      }, null, this.getBeforeMaskedValueChangeConfig());
      newValue = modifiedValue.value;
      newSelection = modifiedValue.selection;
    }

    this.value = newValue;
    var isValueChanged = this.getInputValue() !== this.value; // render depends on this.maskOptions and this.value,
    // call forceUpdate to keep it in sync

    if (isValueChanged) {
      this.setInputValue(this.value);
      this.forceUpdate();
    } else if (isMaskChanged) {
      this.forceUpdate();
    }

    var isSelectionChanged = false;

    if (newSelection.start != null && newSelection.end != null) {
      isSelectionChanged = !previousSelection || previousSelection.start !== newSelection.start || previousSelection.end !== newSelection.end;
    }

    if (isSelectionChanged || isValueChanged) {
      this.setSelection(newSelection.start, newSelection.end);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;

    if (this.selectionDeferId !== null) {
      cancelDefer(this.selectionDeferId);
    }

    this.stopSaveSelectionLoop();
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        mask = _this$props2.mask,
        alwaysShowMask = _this$props2.alwaysShowMask,
        maskChar = _this$props2.maskChar,
        formatChars = _this$props2.formatChars,
        inputRef = _this$props2.inputRef,
        beforeMaskedValueChange = _this$props2.beforeMaskedValueChange,
        children = _this$props2.children,
        restProps = _objectWithoutPropertiesLoose(_this$props2, ["mask", "alwaysShowMask", "maskChar", "formatChars", "inputRef", "beforeMaskedValueChange", "children"]);

    var inputElement;
     true ? warning( // parse mask to test against actual mask prop as this.maskOptions
    // will be updated later in componentDidUpdate
    !restProps.maxLength || !parseMask(mask, maskChar, formatChars).mask, 'react-input-mask: maxLength property shouldn\'t be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length.') : 0;

    if (children) {
      !isFunction(children) ?  true ? invariant(false, 'react-input-mask: children must be a function') : 0 : void 0;
      var controlledProps = ['onChange', 'onPaste', 'onMouseDown', 'onFocus', 'onBlur', 'value', 'disabled', 'readOnly'];

      var childrenProps = _extends({}, restProps);

      controlledProps.forEach(function (propId) {
        return delete childrenProps[propId];
      });
      inputElement = children(childrenProps);
      var conflictProps = controlledProps.filter(function (propId) {
        return inputElement.props[propId] != null && inputElement.props[propId] !== restProps[propId];
      });
      !!conflictProps.length ?  true ? invariant(false, "react-input-mask: the following props should be passed to the react-input-mask's component and should not be altered in children's function: " + conflictProps.join(', ')) : 0 : void 0;
       true ? warning(!inputRef, 'react-input-mask: inputRef is ignored when children is passed, attach ref to the children instead') : 0;
    } else {
      inputElement = React.createElement("input", _extends({
        ref: this.handleRef
      }, restProps));
    }

    var changedProps = {
      onFocus: this.onFocus,
      onBlur: this.onBlur
    };

    if (this.maskOptions.mask) {
      if (!restProps.disabled && !restProps.readOnly) {
        changedProps.onChange = this.onChange;
        changedProps.onPaste = this.onPaste;
        changedProps.onMouseDown = this.onMouseDown;
      }

      if (restProps.value != null) {
        changedProps.value = this.value;
      }
    }

    inputElement = React.cloneElement(inputElement, changedProps);
    return inputElement;
  };

  return InputElement;
}(React.Component);

module.exports = InputElement;


/***/ }),

/***/ "./node_modules/warning/warning.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/warning.js ***!
  \*****************************************/
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "development" !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9mZWVkYmFjay9GZWVkYmFjay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LW1hc2svbGliL3JlYWN0LWlucHV0LW1hc2suZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiXSwibmFtZXMiOlsiRmVlZGJhY2tGb3JtIiwiZ2V0UGhvbmUiLCJ2YWx1ZSIsImRlZmF1bHRNYXNrIiwidXNlU3RhdGUiLCJtYXNrIiwiaXRlbXMiLCJzZXRJdGVtcyIsImZpZWxkIiwicHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSxJQUFNQSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxHQUFNO0FBQUE7O0FBQUE7O0FBQ3pCLE1BQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQUFDLEtBQUssRUFBSTtBQUN4QixRQUFNQyxXQUFXLEdBQUcsa0JBQXBCO0FBQ0EsV0FBT0EsV0FBUDtBQUNELEdBSEQ7O0FBRHlCLGtCQUtBQywrQ0FBUSxDQUFDO0FBQ2hDRixTQUFLLEVBQUUsRUFEeUI7QUFFaENHLFFBQUksRUFBRUosUUFBUTtBQUZrQixHQUFELENBTFI7QUFBQSxNQUtsQkssS0FMa0I7QUFBQSxNQUtaQyxRQUxZOztBQVN6QixzQkFDRTtBQUFLLGFBQVMsRUFBQyxlQUFmO0FBQUEsMkJBQ0U7QUFBQSw4QkFDRTtBQUFPLFlBQUksRUFBQyxNQUFaO0FBQW1CLGlCQUFTLEVBQUMsWUFBN0I7QUFBMEMsbUJBQVcsRUFBQztBQUF0RDtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBREYsZUFFRSw4REFBQyx5REFBRCxnREFDTUQsS0FETjtBQUVFLGdCQUFRLEVBQUUsSUFGWjtBQUdFLGlCQUFTLEVBQUM7QUFIWixTQUlNRSxLQUpOLEdBS01DLEtBTE47QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUZGLGVBUUU7QUFBVSxtQkFBVyxFQUFDO0FBQXRCO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFSRixlQVNFO0FBQ0UsaUJBQVMsRUFBQyxXQURaO0FBRUUsWUFBSSxFQUFDO0FBRlAsaUpBR1ksUUFIWix1SUFJUSx3REFKUjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBVEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBbUJELENBNUJEOztHQUFNVCxZOztLQUFBQSxZO0FBOEJOLCtEQUFlQSxZQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ2hEQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCxFQUFFLHdKQUFpRTtBQUNuRTs7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWIsK0JBQStCLGlGQUFpRjs7QUFFaEgsNEJBQTRCLG1CQUFPLENBQUMsNENBQU87QUFDM0MsZUFBZSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2xDLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFXO0FBQ25ELDhCQUE4QixtQkFBTyxDQUFDLGtEQUFTOztBQUUvQyxvQ0FBb0MsaURBQWlELGdCQUFnQixpQkFBaUIsT0FBTyxtQkFBbUIsNERBQTRELDZEQUE2RCx3Q0FBd0MsRUFBRSxFQUFFLFlBQVk7O0FBRWpVO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXVGO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QztBQUN4Qzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQztBQUMzQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQSw4T0FBOE8sQ0FBTTs7QUFFcFA7QUFDQSw4QkFBOEIsS0FBcUMsdUVBQXVFLENBQWdCO0FBQzFKOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0JBQStCLEtBQXFDLGtNQUFrTSxDQUFnQjtBQUN0UixNQUFNLEtBQXFDLDZIQUE2SCxDQUFNO0FBQzlLLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOzs7Ozs7Ozs7Ozs7QUNybUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxhQUFvQjs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzdGF0aWMvd2VicGFjay9wYWdlcy9mZWVkYmFjay42OWViYWNmNmNkNzZlYzAxODI3OS5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxyXG5pbXBvcnQgSW5wdXRNYXNrIGZyb20gJ3JlYWN0LWlucHV0LW1hc2snXHJcblxyXG5jb25zdCBGZWVkYmFja0Zvcm0gPSAoKSA9PiB7XHJcbiAgY29uc3QgZ2V0UGhvbmUgPSB2YWx1ZSA9PiB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWFzayA9IFwiKzcoOTk5KS05OTktOTk5OVwiO1xyXG4gICAgcmV0dXJuIGRlZmF1bHRNYXNrXHJcbiAgfVxyXG4gIGNvbnN0IFtpdGVtcyxzZXRJdGVtc10gPSB1c2VTdGF0ZSh7XHJcbiAgICB2YWx1ZTogJycsXHJcbiAgICBtYXNrOiBnZXRQaG9uZSgpXHJcbiAgfSlcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9J2Zvcm1fcmVnaXN0ZXInPlxyXG4gICAgICA8Zm9ybT5cclxuICAgICAgICA8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPSdjYXBpdGFsaXplJyBwbGFjZWhvbGRlcj0n0JLQsNGI0LUg0LjQvNGPJz48L2lucHV0PlxyXG4gICAgICAgIDxJbnB1dE1hc2tcclxuICAgICAgICAgIHsuLi5pdGVtc31cclxuICAgICAgICAgIG1hc2tDaGFyPXtudWxsfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXktaW5wdXRcIlxyXG4gICAgICAgICAgey4uLmZpZWxkfVxyXG4gICAgICAgICAgey4uLnByb3BzfS8+XHJcbiAgICAgICAgPHRleHRhcmVhIHBsYWNlaG9sZGVyPSfQntGC0LfRi9CyJz48L3RleHRhcmVhPlxyXG4gICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgY2xhc3NOYW1lPSdzaW5nbGVidG4nXHJcbiAgICAgICAgICB0eXBlPSdzdWJtaXQnXHJcbiAgICAgICAgICBjbGFzc05hbWU9J2J1dHRvbidcclxuICAgICAgICAgIHZhbHVlPSfQntGC0L/RgNCw0LLQuNGC0YwnLz5cclxuICAgICAgPC9mb3JtPlxyXG4gICAgPC9kaXY+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGZWVkYmFja0Zvcm0iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCJpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JlYWN0LWlucHV0LW1hc2sucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFJlYWN0ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JlYWN0JykpO1xudmFyIHJlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgaW52YXJpYW50ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2ludmFyaWFudCcpKTtcbnZhciB3YXJuaW5nID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3dhcm5pbmcnKSk7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0czIob2JqLCBkZWZhdWx0cykgeyB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTsgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7IHZhciBrZXkgPSBrZXlzW2ldOyB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpOyBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7IH0gfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcblxuICBfZGVmYXVsdHMyKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIHNldElucHV0U2VsZWN0aW9uKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0ICYmICdzZWxlY3Rpb25FbmQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgIHJhbmdlLnNlbGVjdCgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbnB1dFNlbGVjdGlvbihpbnB1dCkge1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCAmJiAnc2VsZWN0aW9uRW5kJyBpbiBpbnB1dCkge1xuICAgIHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuICB9IGVsc2Uge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuXG4gICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgIHN0YXJ0ID0gLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgICBlbmQgPSAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gICAgbGVuZ3RoOiBlbmQgLSBzdGFydFxuICB9O1xufVxuXG52YXIgZGVmYXVsdEZvcm1hdENoYXJzID0ge1xuICAnOSc6ICdbMC05XScsXG4gICdhJzogJ1tBLVphLXpdJyxcbiAgJyonOiAnW0EtWmEtejAtOV0nXG59O1xudmFyIGRlZmF1bHRNYXNrQ2hhciA9ICdfJztcblxuZnVuY3Rpb24gcGFyc2VNYXNrIChtYXNrLCBtYXNrQ2hhciwgZm9ybWF0Q2hhcnMpIHtcbiAgdmFyIHBhcnNlZE1hc2tTdHJpbmcgPSAnJztcbiAgdmFyIHByZWZpeCA9ICcnO1xuICB2YXIgbGFzdEVkaXRhYmxlUG9zaXRpb24gPSBudWxsO1xuICB2YXIgcGVybWFuZW50cyA9IFtdO1xuXG4gIGlmIChtYXNrQ2hhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFza0NoYXIgPSBkZWZhdWx0TWFza0NoYXI7XG4gIH1cblxuICBpZiAoZm9ybWF0Q2hhcnMgPT0gbnVsbCkge1xuICAgIGZvcm1hdENoYXJzID0gZGVmYXVsdEZvcm1hdENoYXJzO1xuICB9XG5cbiAgaWYgKCFtYXNrIHx8IHR5cGVvZiBtYXNrICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBtYXNrQ2hhcjogbWFza0NoYXIsXG4gICAgICBmb3JtYXRDaGFyczogZm9ybWF0Q2hhcnMsXG4gICAgICBtYXNrOiBudWxsLFxuICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgbGFzdEVkaXRhYmxlUG9zaXRpb246IG51bGwsXG4gICAgICBwZXJtYW5lbnRzOiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgaXNQZXJtYW5lbnQgPSBmYWxzZTtcbiAgbWFzay5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgaWYgKCFpc1Blcm1hbmVudCAmJiBjaGFyYWN0ZXIgPT09ICdcXFxcJykge1xuICAgICAgaXNQZXJtYW5lbnQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQZXJtYW5lbnQgfHwgIWZvcm1hdENoYXJzW2NoYXJhY3Rlcl0pIHtcbiAgICAgICAgcGVybWFuZW50cy5wdXNoKHBhcnNlZE1hc2tTdHJpbmcubGVuZ3RoKTtcblxuICAgICAgICBpZiAocGFyc2VkTWFza1N0cmluZy5sZW5ndGggPT09IHBlcm1hbmVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHByZWZpeCArPSBjaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uID0gcGFyc2VkTWFza1N0cmluZy5sZW5ndGggKyAxO1xuICAgICAgfVxuXG4gICAgICBwYXJzZWRNYXNrU3RyaW5nICs9IGNoYXJhY3RlcjtcbiAgICAgIGlzUGVybWFuZW50ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtYXNrQ2hhcjogbWFza0NoYXIsXG4gICAgZm9ybWF0Q2hhcnM6IGZvcm1hdENoYXJzLFxuICAgIHByZWZpeDogcHJlZml4LFxuICAgIG1hc2s6IHBhcnNlZE1hc2tTdHJpbmcsXG4gICAgbGFzdEVkaXRhYmxlUG9zaXRpb246IGxhc3RFZGl0YWJsZVBvc2l0aW9uLFxuICAgIHBlcm1hbmVudHM6IHBlcm1hbmVudHNcbiAgfTtcbn1cblxuLyogZXNsaW50IG5vLXVzZS1iZWZvcmUtZGVmaW5lOiBbXCJlcnJvclwiLCB7IGZ1bmN0aW9uczogZmFsc2UgfV0gKi9cbmZ1bmN0aW9uIGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MpIHtcbiAgcmV0dXJuIG1hc2tPcHRpb25zLnBlcm1hbmVudHMuaW5kZXhPZihwb3MpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGlzQWxsb3dlZENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zLCBjaGFyYWN0ZXIpIHtcbiAgdmFyIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgZm9ybWF0Q2hhcnMgPSBtYXNrT3B0aW9ucy5mb3JtYXRDaGFycztcblxuICBpZiAoIWNoYXJhY3Rlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zKSkge1xuICAgIHJldHVybiBtYXNrW3Bvc10gPT09IGNoYXJhY3RlcjtcbiAgfVxuXG4gIHZhciBydWxlQ2hhciA9IG1hc2tbcG9zXTtcbiAgdmFyIGNoYXJSdWxlID0gZm9ybWF0Q2hhcnNbcnVsZUNoYXJdO1xuICByZXR1cm4gbmV3IFJlZ0V4cChjaGFyUnVsZSkudGVzdChjaGFyYWN0ZXIpO1xufVxuZnVuY3Rpb24gaXNFbXB0eShtYXNrT3B0aW9ucywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKS5ldmVyeShmdW5jdGlvbiAoY2hhcmFjdGVyLCBpKSB7XG4gICAgcmV0dXJuIGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSB8fCAhaXNBbGxvd2VkQ2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpLCBjaGFyYWN0ZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpbGxlZExlbmd0aChtYXNrT3B0aW9ucywgdmFsdWUpIHtcbiAgdmFyIG1hc2tDaGFyID0gbWFza09wdGlvbnMubWFza0NoYXIsXG4gICAgICBwcmVmaXggPSBtYXNrT3B0aW9ucy5wcmVmaXg7XG5cbiAgaWYgKCFtYXNrQ2hhcikge1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPiBwcmVmaXgubGVuZ3RoICYmIGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCB2YWx1ZS5sZW5ndGggLSAxKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGZpbGxlZExlbmd0aCA9IHByZWZpeC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IHZhbHVlLmxlbmd0aDsgaSA+PSBwcmVmaXgubGVuZ3RoOyBpLS0pIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdmFsdWVbaV07XG4gICAgdmFyIGlzRW50ZXJlZENoYXJhY3RlciA9ICFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkgJiYgaXNBbGxvd2VkQ2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpLCBjaGFyYWN0ZXIpO1xuXG4gICAgaWYgKGlzRW50ZXJlZENoYXJhY3Rlcikge1xuICAgICAgZmlsbGVkTGVuZ3RoID0gaSArIDE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsbGVkTGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNGaWxsZWQobWFza09wdGlvbnMsIHZhbHVlKSB7XG4gIHJldHVybiBnZXRGaWxsZWRMZW5ndGgobWFza09wdGlvbnMsIHZhbHVlKSA9PT0gbWFza09wdGlvbnMubWFzay5sZW5ndGg7XG59XG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShtYXNrT3B0aW9ucywgdmFsdWUpIHtcbiAgdmFyIG1hc2tDaGFyID0gbWFza09wdGlvbnMubWFza0NoYXIsXG4gICAgICBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIHByZWZpeCA9IG1hc2tPcHRpb25zLnByZWZpeDtcblxuICBpZiAoIW1hc2tDaGFyKSB7XG4gICAgdmFsdWUgPSBpbnNlcnRTdHJpbmcobWFza09wdGlvbnMsICcnLCB2YWx1ZSwgMCk7XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoIDwgcHJlZml4Lmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBwcmVmaXg7XG4gICAgfVxuXG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IG1hc2subGVuZ3RoICYmIGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCB2YWx1ZS5sZW5ndGgpKSB7XG4gICAgICB2YWx1ZSArPSBtYXNrW3ZhbHVlLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgdmFyIGVtcHR5VmFsdWUgPSBmb3JtYXRWYWx1ZShtYXNrT3B0aW9ucywgJycpO1xuICAgIHJldHVybiBpbnNlcnRTdHJpbmcobWFza09wdGlvbnMsIGVtcHR5VmFsdWUsIHZhbHVlLCAwKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkpIHtcbiAgICAgIHZhbHVlICs9IG1hc2tbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IG1hc2tDaGFyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNsZWFyUmFuZ2UobWFza09wdGlvbnMsIHZhbHVlLCBzdGFydCwgbGVuKSB7XG4gIHZhciBlbmQgPSBzdGFydCArIGxlbjtcbiAgdmFyIG1hc2tDaGFyID0gbWFza09wdGlvbnMubWFza0NoYXIsXG4gICAgICBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIHByZWZpeCA9IG1hc2tPcHRpb25zLnByZWZpeDtcbiAgdmFyIGFycmF5VmFsdWUgPSB2YWx1ZS5zcGxpdCgnJyk7XG5cbiAgaWYgKCFtYXNrQ2hhcikge1xuICAgIC8vIHJlbW92ZSBhbnkgcGVybWFuZW50IGNoYXJzIGFmdGVyIGNsZWFyIHJhbmdlLCB0aGV5IHdpbGwgYmUgYWRkZWQgYmFjayBieSBmb3JtYXRWYWx1ZVxuICAgIGZvciAodmFyIGkgPSBlbmQ7IGkgPCBhcnJheVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpKSB7XG4gICAgICAgIGFycmF5VmFsdWVbaV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydCA9IE1hdGgubWF4KHByZWZpeC5sZW5ndGgsIHN0YXJ0KTtcbiAgICBhcnJheVZhbHVlLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIHZhbHVlID0gYXJyYXlWYWx1ZS5qb2luKCcnKTtcbiAgICByZXR1cm4gZm9ybWF0VmFsdWUobWFza09wdGlvbnMsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVZhbHVlLm1hcChmdW5jdGlvbiAoY2hhcmFjdGVyLCBpKSB7XG4gICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICB9XG5cbiAgICBpZiAoaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpKSB7XG4gICAgICByZXR1cm4gbWFza1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFza0NoYXI7XG4gIH0pLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3RyaW5nKG1hc2tPcHRpb25zLCB2YWx1ZSwgaW5zZXJ0U3RyLCBpbnNlcnRQb3NpdGlvbikge1xuICB2YXIgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQ2hhciA9IG1hc2tPcHRpb25zLm1hc2tDaGFyLFxuICAgICAgcHJlZml4ID0gbWFza09wdGlvbnMucHJlZml4O1xuICB2YXIgYXJyYXlJbnNlcnRTdHIgPSBpbnNlcnRTdHIuc3BsaXQoJycpO1xuICB2YXIgaXNJbnB1dEZpbGxlZCA9IGlzRmlsbGVkKG1hc2tPcHRpb25zLCB2YWx1ZSk7XG5cbiAgdmFyIGlzVXNhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiBpc1VzYWJsZVBvc2l0aW9uKHBvcywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuICFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zKSB8fCBjaGFyYWN0ZXIgPT09IG1hc2tbcG9zXTtcbiAgfTtcblxuICB2YXIgaXNVc2FibGVDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1VzYWJsZUNoYXJhY3RlcihjaGFyYWN0ZXIsIHBvcykge1xuICAgIHJldHVybiAhbWFza0NoYXIgfHwgIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MpIHx8IGNoYXJhY3RlciAhPT0gbWFza0NoYXI7XG4gIH07XG5cbiAgaWYgKCFtYXNrQ2hhciAmJiBpbnNlcnRQb3NpdGlvbiA+IHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlICs9IG1hc2suc2xpY2UodmFsdWUubGVuZ3RoLCBpbnNlcnRQb3NpdGlvbik7XG4gIH1cblxuICBhcnJheUluc2VydFN0ci5ldmVyeShmdW5jdGlvbiAoaW5zZXJ0Q2hhcmFjdGVyKSB7XG4gICAgd2hpbGUgKCFpc1VzYWJsZVBvc2l0aW9uKGluc2VydFBvc2l0aW9uLCBpbnNlcnRDaGFyYWN0ZXIpKSB7XG4gICAgICBpZiAoaW5zZXJ0UG9zaXRpb24gPj0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlICs9IG1hc2tbaW5zZXJ0UG9zaXRpb25dO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVXNhYmxlQ2hhcmFjdGVyKGluc2VydENoYXJhY3RlciwgaW5zZXJ0UG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbnNlcnRQb3NpdGlvbisrOyAvLyBzdG9wIGl0ZXJhdGlvbiBpZiBtYXhpbXVtIHZhbHVlIGxlbmd0aCByZWFjaGVkXG5cbiAgICAgIGlmIChpbnNlcnRQb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzQWxsb3dlZENoYXJhY3RlcihtYXNrT3B0aW9ucywgaW5zZXJ0UG9zaXRpb24sIGluc2VydENoYXJhY3RlcikgfHwgaW5zZXJ0Q2hhcmFjdGVyID09PSBtYXNrQ2hhcjtcblxuICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5zZXJ0UG9zaXRpb24gPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmIChtYXNrQ2hhciB8fCBpc0lucHV0RmlsbGVkIHx8IGluc2VydFBvc2l0aW9uIDwgcHJlZml4Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGluc2VydFBvc2l0aW9uKSArIGluc2VydENoYXJhY3RlciArIHZhbHVlLnNsaWNlKGluc2VydFBvc2l0aW9uICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGluc2VydFBvc2l0aW9uKSArIGluc2VydENoYXJhY3RlciArIHZhbHVlLnNsaWNlKGluc2VydFBvc2l0aW9uKTtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRWYWx1ZShtYXNrT3B0aW9ucywgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW1hc2tDaGFyKSB7XG4gICAgICB2YWx1ZSArPSBpbnNlcnRDaGFyYWN0ZXI7XG4gICAgfVxuXG4gICAgaW5zZXJ0UG9zaXRpb24rKzsgLy8gc3RvcCBpdGVyYXRpb24gaWYgbWF4aW11bSB2YWx1ZSBsZW5ndGggcmVhY2hlZFxuXG4gICAgcmV0dXJuIGluc2VydFBvc2l0aW9uIDwgbWFzay5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRJbnNlcnRTdHJpbmdMZW5ndGgobWFza09wdGlvbnMsIHZhbHVlLCBpbnNlcnRTdHIsIGluc2VydFBvc2l0aW9uKSB7XG4gIHZhciBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIG1hc2tDaGFyID0gbWFza09wdGlvbnMubWFza0NoYXI7XG4gIHZhciBhcnJheUluc2VydFN0ciA9IGluc2VydFN0ci5zcGxpdCgnJyk7XG4gIHZhciBpbml0aWFsSW5zZXJ0UG9zaXRpb24gPSBpbnNlcnRQb3NpdGlvbjtcblxuICB2YXIgaXNVc2FibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIGlzVXNhYmxlUG9zaXRpb24ocG9zLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gIWlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBwb3MpIHx8IGNoYXJhY3RlciA9PT0gbWFza1twb3NdO1xuICB9O1xuXG4gIGFycmF5SW5zZXJ0U3RyLmV2ZXJ5KGZ1bmN0aW9uIChpbnNlcnRDaGFyYWN0ZXIpIHtcbiAgICB3aGlsZSAoIWlzVXNhYmxlUG9zaXRpb24oaW5zZXJ0UG9zaXRpb24sIGluc2VydENoYXJhY3RlcikpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uKys7IC8vIHN0b3AgaXRlcmF0aW9uIGlmIG1heGltdW0gdmFsdWUgbGVuZ3RoIHJlYWNoZWRcblxuICAgICAgaWYgKGluc2VydFBvc2l0aW9uID49IG1hc2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNBbGxvd2VkID0gaXNBbGxvd2VkQ2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpbnNlcnRQb3NpdGlvbiwgaW5zZXJ0Q2hhcmFjdGVyKSB8fCBpbnNlcnRDaGFyYWN0ZXIgPT09IG1hc2tDaGFyO1xuXG4gICAgaWYgKGlzQWxsb3dlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb24rKztcbiAgICB9IC8vIHN0b3AgaXRlcmF0aW9uIGlmIG1heGltdW0gdmFsdWUgbGVuZ3RoIHJlYWNoZWRcblxuXG4gICAgcmV0dXJuIGluc2VydFBvc2l0aW9uIDwgbWFzay5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gaW5zZXJ0UG9zaXRpb24gLSBpbml0aWFsSW5zZXJ0UG9zaXRpb247XG59XG5mdW5jdGlvbiBnZXRMZWZ0RWRpdGFibGVQb3NpdGlvbihtYXNrT3B0aW9ucywgcG9zKSB7XG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKCFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKG1hc2tPcHRpb25zLCBwb3MpIHtcbiAgdmFyIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBtYXNrLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCA/ICcnIDogdmFsdWUgKyAnJztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoYW5nZShtYXNrT3B0aW9ucywgdmFsdWUsIHNlbGVjdGlvbiwgcHJldmlvdXNWYWx1ZSwgcHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgdmFyIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgcHJlZml4ID0gbWFza09wdGlvbnMucHJlZml4LFxuICAgICAgbGFzdEVkaXRhYmxlUG9zaXRpb24gPSBtYXNrT3B0aW9ucy5sYXN0RWRpdGFibGVQb3NpdGlvbjtcbiAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG4gIHZhciBlbnRlcmVkU3RyaW5nID0gJyc7XG4gIHZhciBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgdmFyIHJlbW92ZWRMZW5ndGggPSAwO1xuICB2YXIgY3Vyc29yUG9zaXRpb24gPSBNYXRoLm1pbihwcmV2aW91c1NlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLnN0YXJ0KTtcblxuICBpZiAoc2VsZWN0aW9uLmVuZCA+IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0KSB7XG4gICAgZW50ZXJlZFN0cmluZyA9IG5ld1ZhbHVlLnNsaWNlKHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0LCBzZWxlY3Rpb24uZW5kKTtcbiAgICBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoID0gZ2V0SW5zZXJ0U3RyaW5nTGVuZ3RoKG1hc2tPcHRpb25zLCBwcmV2aW91c1ZhbHVlLCBlbnRlcmVkU3RyaW5nLCBjdXJzb3JQb3NpdGlvbik7XG5cbiAgICBpZiAoIWZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGgpIHtcbiAgICAgIHJlbW92ZWRMZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVkTGVuZ3RoID0gcHJldmlvdXNTZWxlY3Rpb24ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXdWYWx1ZS5sZW5ndGggPCBwcmV2aW91c1ZhbHVlLmxlbmd0aCkge1xuICAgIHJlbW92ZWRMZW5ndGggPSBwcmV2aW91c1ZhbHVlLmxlbmd0aCAtIG5ld1ZhbHVlLmxlbmd0aDtcbiAgfVxuXG4gIG5ld1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcblxuICBpZiAocmVtb3ZlZExlbmd0aCkge1xuICAgIGlmIChyZW1vdmVkTGVuZ3RoID09PSAxICYmICFwcmV2aW91c1NlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgIHZhciBkZWxldGVGcm9tUmlnaHQgPSBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCA9PT0gc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgY3Vyc29yUG9zaXRpb24gPSBkZWxldGVGcm9tUmlnaHQgPyBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24obWFza09wdGlvbnMsIHNlbGVjdGlvbi5zdGFydCkgOiBnZXRMZWZ0RWRpdGFibGVQb3NpdGlvbihtYXNrT3B0aW9ucywgc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IGNsZWFyUmFuZ2UobWFza09wdGlvbnMsIG5ld1ZhbHVlLCBjdXJzb3JQb3NpdGlvbiwgcmVtb3ZlZExlbmd0aCk7XG4gIH1cblxuICBuZXdWYWx1ZSA9IGluc2VydFN0cmluZyhtYXNrT3B0aW9ucywgbmV3VmFsdWUsIGVudGVyZWRTdHJpbmcsIGN1cnNvclBvc2l0aW9uKTtcbiAgY3Vyc29yUG9zaXRpb24gPSBjdXJzb3JQb3NpdGlvbiArIGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGg7XG5cbiAgaWYgKGN1cnNvclBvc2l0aW9uID49IG1hc2subGVuZ3RoKSB7XG4gICAgY3Vyc29yUG9zaXRpb24gPSBtYXNrLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChjdXJzb3JQb3NpdGlvbiA8IHByZWZpeC5sZW5ndGggJiYgIWZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGgpIHtcbiAgICBjdXJzb3JQb3NpdGlvbiA9IHByZWZpeC5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoY3Vyc29yUG9zaXRpb24gPj0gcHJlZml4Lmxlbmd0aCAmJiBjdXJzb3JQb3NpdGlvbiA8IGxhc3RFZGl0YWJsZVBvc2l0aW9uICYmIGZvcm1hdHRlZEVudGVyZWRTdHJpbmdMZW5ndGgpIHtcbiAgICBjdXJzb3JQb3NpdGlvbiA9IGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihtYXNrT3B0aW9ucywgY3Vyc29yUG9zaXRpb24pO1xuICB9XG5cbiAgbmV3VmFsdWUgPSBmb3JtYXRWYWx1ZShtYXNrT3B0aW9ucywgbmV3VmFsdWUpO1xuXG4gIGlmICghZW50ZXJlZFN0cmluZykge1xuICAgIGVudGVyZWRTdHJpbmcgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgZW50ZXJlZFN0cmluZzogZW50ZXJlZFN0cmluZyxcbiAgICBzZWxlY3Rpb246IHtcbiAgICAgIHN0YXJ0OiBjdXJzb3JQb3NpdGlvbixcbiAgICAgIGVuZDogY3Vyc29yUG9zaXRpb25cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzV2luZG93c1Bob25lQnJvd3NlcigpIHtcbiAgdmFyIHdpbmRvd3MgPSBuZXcgUmVnRXhwKCd3aW5kb3dzJywgJ2knKTtcbiAgdmFyIHBob25lID0gbmV3IFJlZ0V4cCgncGhvbmUnLCAnaScpO1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gd2luZG93cy50ZXN0KHVhKSAmJiBwaG9uZS50ZXN0KHVhKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB7XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FuY2VsQW5pbWF0aW9uRnJhbWUoKSB7XG4gIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZWZlcihmbikge1xuICB2YXIgaGFzQ2FuY2VsQW5pbWF0aW9uRnJhbWUgPSAhIWdldENhbmNlbEFuaW1hdGlvbkZyYW1lKCk7XG4gIHZhciBkZWZlckZuO1xuXG4gIGlmIChoYXNDYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIGRlZmVyRm4gPSBnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZlckZuID0gZnVuY3Rpb24gZGVmZXJGbigpIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCAxMDAwIC8gNjApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGVmZXJGbihmbik7XG59XG5mdW5jdGlvbiBjYW5jZWxEZWZlcihkZWZlcklkKSB7XG4gIHZhciBjYW5jZWxGbiA9IGdldENhbmNlbEFuaW1hdGlvbkZyYW1lKCkgfHwgY2xlYXJUaW1lb3V0O1xuICBjYW5jZWxGbihkZWZlcklkKTtcbn1cblxudmFyIElucHV0RWxlbWVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShJbnB1dEVsZW1lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElucHV0RWxlbWVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgX3RoaXMucHJldmlvdXNTZWxlY3Rpb24gPSBudWxsO1xuICAgIF90aGlzLnNlbGVjdGlvbkRlZmVySWQgPSBudWxsO1xuICAgIF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCA9IG51bGw7XG5cbiAgICBfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnByZXZpb3VzU2VsZWN0aW9uID0gX3RoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQgPSBkZWZlcihfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcCk7XG4gICAgfTtcblxuICAgIF90aGlzLnJ1blNhdmVTZWxlY3Rpb25Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5zdG9wU2F2ZVNlbGVjdGlvbkxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbERlZmVyKF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCk7XG4gICAgICAgIF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCA9IG51bGw7XG4gICAgICAgIF90aGlzLnByZXZpb3VzU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0SW5wdXRET01Ob2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5tb3VudGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSByZWFjdERvbS5maW5kRE9NTm9kZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgICB2YXIgaXNET01Ob2RlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudDsgLy8gd29ya2Fyb3VuZCBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTQ3XG5cbiAgICAgIGlmIChpbnB1dCAmJiAhaXNET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXQubm9kZU5hbWUgIT09ICdJTlBVVCcpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3QtaW5wdXQtbWFzazogaW5wdXRDb21wb25lbnQgZG9lc25cXCd0IGNvbnRhaW4gaW5wdXQgbm9kZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcblxuICAgIF90aGlzLmdldElucHV0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcblxuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0LnZhbHVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRJbnB1dFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcblxuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRDdXJzb3JUb0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxsZWRMZW5ndGggPSBnZXRGaWxsZWRMZW5ndGgoX3RoaXMubWFza09wdGlvbnMsIF90aGlzLnZhbHVlKTtcbiAgICAgIHZhciBwb3MgPSBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24oX3RoaXMubWFza09wdGlvbnMsIGZpbGxlZExlbmd0aCk7XG5cbiAgICAgIGlmIChwb3MgIT09IG51bGwpIHtcbiAgICAgICAgX3RoaXMuc2V0Q3Vyc29yUG9zaXRpb24ocG9zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcblxuICAgICAgdmFyIGlzRm9jdXNlZCA9IF90aGlzLmlzRm9jdXNlZCgpOyAvLyBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIG9uIHVuZm9jdXNlZCBpbnB1dFxuICAgICAgLy8gYmVjYXVzZSBTYWZhcmkgc2V0cyBmb2N1cyBvbiBzZWxlY3Rpb24gY2hhbmdlICgjMTU0KVxuXG5cbiAgICAgIGlmICghaW5wdXQgfHwgIWlzRm9jdXNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgICAgZGVmZXJyZWQgPSBfb3B0aW9ucy5kZWZlcnJlZDtcblxuICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICBzZXRJbnB1dFNlbGVjdGlvbihpbnB1dCwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5zZWxlY3Rpb25EZWZlcklkICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbERlZmVyKF90aGlzLnNlbGVjdGlvbkRlZmVySWQpO1xuICAgICAgfSAvLyBkZWZlcnJlZCBzZWxlY3Rpb24gdXBkYXRlIGlzIHJlcXVpcmVkIGZvciBwcmUtTG9sbGlwb3AgQW5kcm9pZCBicm93c2VyLFxuICAgICAgLy8gYnV0IGZvciBjb25zaXN0ZW50IGJlaGF2aW9yIHdlIGRvIGl0IGZvciBhbGwgYnJvd3NlcnNcblxuXG4gICAgICBfdGhpcy5zZWxlY3Rpb25EZWZlcklkID0gZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zZWxlY3Rpb25EZWZlcklkID0gbnVsbDtcbiAgICAgICAgc2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5wcmV2aW91c1NlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgbGVuZ3RoOiBNYXRoLmFicyhlbmQgLSBzdGFydClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0RE9NTm9kZSgpO1xuXG4gICAgICByZXR1cm4gZ2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRDdXJzb3JQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5nZXRTZWxlY3Rpb24oKS5zdGFydDtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0Q3Vyc29yUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICBfdGhpcy5zZXRTZWxlY3Rpb24ocG9zLCBwb3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5pc0ZvY3VzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZm9jdXNlZDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFza09wdGlvbnMgPSBfdGhpcy5tYXNrT3B0aW9ucyxcbiAgICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnMubWFzayxcbiAgICAgICAgICBtYXNrQ2hhciA9IF90aGlzJG1hc2tPcHRpb25zLm1hc2tDaGFyLFxuICAgICAgICAgIHBlcm1hbmVudHMgPSBfdGhpcyRtYXNrT3B0aW9ucy5wZXJtYW5lbnRzLFxuICAgICAgICAgIGZvcm1hdENoYXJzID0gX3RoaXMkbWFza09wdGlvbnMuZm9ybWF0Q2hhcnM7XG4gICAgICB2YXIgYWx3YXlzU2hvd01hc2sgPSBfdGhpcy5wcm9wcy5hbHdheXNTaG93TWFzaztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hc2s6IG1hc2ssXG4gICAgICAgIG1hc2tDaGFyOiBtYXNrQ2hhcixcbiAgICAgICAgcGVybWFuZW50czogcGVybWFuZW50cyxcbiAgICAgICAgYWx3YXlzU2hvd01hc2s6ICEhYWx3YXlzU2hvd01hc2ssXG4gICAgICAgIGZvcm1hdENoYXJzOiBmb3JtYXRDaGFyc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaXNJbnB1dEF1dG9maWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIHNlbGVjdGlvbiwgcHJldmlvdXNWYWx1ZSwgcHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBpbnB1dCA9IF90aGlzLmdldElucHV0RE9NTm9kZSgpOyAvLyBvbmx5IGNoZWNrIGZvciBwb3NpdGl2ZSBtYXRjaCBiZWNhdXNlIGl0IHdpbGwgYmUgZmFsc2UgbmVnYXRpdmVcbiAgICAgIC8vIGluIGNhc2Ugb2YgYXV0b2ZpbGwgc2ltdWxhdGlvbiBpbiB0ZXN0c1xuICAgICAgLy9cbiAgICAgIC8vIGlucHV0Lm1hdGNoZXMgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBzZWxlY3RvciBpc24ndCBzdXBwb3J0ZWRcblxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2hlcygnOi13ZWJraXQtYXV0b2ZpbGwnKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fSAvLyBpZiBpbnB1dCBpc24ndCBmb2N1c2VkIHRoZW4gY2hhbmdlIGV2ZW50IG11c3QgaGF2ZSBiZWVuIHRyaWdnZXJlZFxuICAgICAgLy8gZWl0aGVyIGJ5IGF1dG9maWxsIG9yIGV2ZW50IHNpbXVsYXRpb24gaW4gdGVzdHNcblxuXG4gICAgICBpZiAoIV90aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGlmIGN1cnNvciBoYXMgbW92ZWQgdG8gdGhlIGVuZCB3aGlsZSBwcmV2aW91c1NlbGVjdGlvbiBmb3JiaWRzIGl0XG4gICAgICAvLyB0aGVuIGl0IG11c3QgYmUgYXV0b2ZpbGxcblxuXG4gICAgICByZXR1cm4gcHJldmlvdXNTZWxlY3Rpb24uZW5kIDwgcHJldmlvdXNWYWx1ZS5sZW5ndGggJiYgc2VsZWN0aW9uLmVuZCA9PT0gdmFsdWUubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICAgIGJlZm9yZVBhc3RlU3RhdGUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemUuYmVmb3JlUGFzdGVTdGF0ZTtcblxuICAgICAgdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZTIgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgICBwcmV2aW91c1NlbGVjdGlvbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZTIucHJldmlvdXNTZWxlY3Rpb247XG5cbiAgICAgIHZhciBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IF90aGlzLnByb3BzLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlO1xuXG4gICAgICB2YXIgdmFsdWUgPSBfdGhpcy5nZXRJbnB1dFZhbHVlKCk7XG5cbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gX3RoaXMudmFsdWU7XG5cbiAgICAgIHZhciBzZWxlY3Rpb24gPSBfdGhpcy5nZXRTZWxlY3Rpb24oKTsgLy8gYXV0b2ZpbGwgcmVwbGFjZXMgZW50aXJlIHZhbHVlLCBpZ25vcmUgb2xkIG9uZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Nhbm5pYXNzaW4vcmVhY3QtaW5wdXQtbWFzay9pc3N1ZXMvMTEzXG5cblxuICAgICAgaWYgKF90aGlzLmlzSW5wdXRBdXRvZmlsbGVkKHZhbHVlLCBzZWxlY3Rpb24sIHByZXZpb3VzVmFsdWUsIHByZXZpb3VzU2VsZWN0aW9uKSkge1xuICAgICAgICBwcmV2aW91c1ZhbHVlID0gZm9ybWF0VmFsdWUoX3RoaXMubWFza09wdGlvbnMsICcnKTtcbiAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9O1xuICAgICAgfSAvLyBzZXQgdmFsdWUgYW5kIHNlbGVjdGlvbiBhcyBpZiB3ZSBoYXZlbid0XG4gICAgICAvLyBjbGVhcmVkIGlucHV0IGluIG9uUGFzdGUgaGFuZGxlclxuXG5cbiAgICAgIGlmIChiZWZvcmVQYXN0ZVN0YXRlKSB7XG4gICAgICAgIHByZXZpb3VzU2VsZWN0aW9uID0gYmVmb3JlUGFzdGVTdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBiZWZvcmVQYXN0ZVN0YXRlLnZhbHVlO1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ICsgdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIGVuZDogcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgKyB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlID0gcHJldmlvdXNWYWx1ZS5zbGljZSgwLCBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCkgKyB2YWx1ZSArIHByZXZpb3VzVmFsdWUuc2xpY2UocHJldmlvdXNTZWxlY3Rpb24uZW5kKTtcbiAgICAgICAgX3RoaXMuYmVmb3JlUGFzdGVTdGF0ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VkU3RhdGUgPSBwcm9jZXNzQ2hhbmdlKF90aGlzLm1hc2tPcHRpb25zLCB2YWx1ZSwgc2VsZWN0aW9uLCBwcmV2aW91c1ZhbHVlLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICB2YXIgZW50ZXJlZFN0cmluZyA9IGNoYW5nZWRTdGF0ZS5lbnRlcmVkU3RyaW5nO1xuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IGNoYW5nZWRTdGF0ZS5zZWxlY3Rpb247XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjaGFuZ2VkU3RhdGUudmFsdWU7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKSkge1xuICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cbiAgICAgICAgfSwge1xuICAgICAgICAgIHZhbHVlOiBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjogcHJldmlvdXNTZWxlY3Rpb25cbiAgICAgICAgfSwgZW50ZXJlZFN0cmluZywgX3RoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcoKSk7XG4gICAgICAgIG5ld1ZhbHVlID0gbW9kaWZpZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgbmV3U2VsZWN0aW9uID0gbW9kaWZpZWRWYWx1ZS5zZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldElucHV0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbkNoYW5nZSkpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuaXNXaW5kb3dzUGhvbmVCcm93c2VyKSB7XG4gICAgICAgIF90aGlzLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24uc3RhcnQsIG5ld1NlbGVjdGlvbi5lbmQsIHtcbiAgICAgICAgICBkZWZlcnJlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24uc3RhcnQsIG5ld1NlbGVjdGlvbi5lbmQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBfdGhpcy5wcm9wcy5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZTtcbiAgICAgIHZhciBfdGhpcyRtYXNrT3B0aW9uczIgPSBfdGhpcy5tYXNrT3B0aW9ucyxcbiAgICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnMyLm1hc2ssXG4gICAgICAgICAgcHJlZml4ID0gX3RoaXMkbWFza09wdGlvbnMyLnByZWZpeDtcbiAgICAgIF90aGlzLmZvY3VzZWQgPSB0cnVlOyAvLyBpZiBhdXRvRm9jdXMgaXMgc2V0LCBvbkZvY3VzIHRyaWdnZXJzIGJlZm9yZSBjb21wb25lbnREaWRNb3VudFxuXG4gICAgICBfdGhpcy5tb3VudGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgaWYgKCFfdGhpcy52YWx1ZSkge1xuICAgICAgICAgIHZhciBlbXB0eVZhbHVlID0gZm9ybWF0VmFsdWUoX3RoaXMubWFza09wdGlvbnMsIHByZWZpeCk7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gZm9ybWF0VmFsdWUoX3RoaXMubWFza09wdGlvbnMsIGVtcHR5VmFsdWUpO1xuICAgICAgICAgIHZhciBmaWxsZWRMZW5ndGggPSBnZXRGaWxsZWRMZW5ndGgoX3RoaXMubWFza09wdGlvbnMsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24oX3RoaXMubWFza09wdGlvbnMsIGZpbGxlZExlbmd0aCk7XG4gICAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBjdXJzb3JQb3NpdGlvbixcbiAgICAgICAgICAgIGVuZDogY3Vyc29yUG9zaXRpb25cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UpKSB7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMudmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogbnVsbFxuICAgICAgICAgICAgfSwgbnVsbCwgX3RoaXMuZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWcoKSk7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG1vZGlmaWVkVmFsdWUudmFsdWU7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSBtb2RpZmllZFZhbHVlLnNlbGVjdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNJbnB1dFZhbHVlQ2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBfdGhpcy5nZXRJbnB1dFZhbHVlKCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnB1dFZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0SW5wdXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzSW5wdXRWYWx1ZUNoYW5nZWQgJiYgaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbkNoYW5nZSkpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uLnN0YXJ0LCBuZXdTZWxlY3Rpb24uZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChnZXRGaWxsZWRMZW5ndGgoX3RoaXMubWFza09wdGlvbnMsIF90aGlzLnZhbHVlKSA8IF90aGlzLm1hc2tPcHRpb25zLm1hc2subGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXMuc2V0Q3Vyc29yVG9FbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnJ1blNhdmVTZWxlY3Rpb25Mb29wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uRm9jdXMpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRm9jdXMoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IF90aGlzLnByb3BzLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlO1xuICAgICAgdmFyIG1hc2sgPSBfdGhpcy5tYXNrT3B0aW9ucy5tYXNrO1xuXG4gICAgICBfdGhpcy5zdG9wU2F2ZVNlbGVjdGlvbkxvb3AoKTtcblxuICAgICAgX3RoaXMuZm9jdXNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAobWFzayAmJiAhX3RoaXMucHJvcHMuYWx3YXlzU2hvd01hc2sgJiYgaXNFbXB0eShfdGhpcy5tYXNrT3B0aW9ucywgX3RoaXMudmFsdWUpKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9ICcnO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKSkge1xuICAgICAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2Uoe1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdmFsdWU6IF90aGlzLnZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBfdGhpcy5wcmV2aW91c1NlbGVjdGlvblxuICAgICAgICAgIH0sIG51bGwsIF90aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnKCkpO1xuICAgICAgICAgIG5ld1ZhbHVlID0gbW9kaWZpZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0lucHV0VmFsdWVDaGFuZ2VkID0gbmV3VmFsdWUgIT09IF90aGlzLmdldElucHV0VmFsdWUoKTtcblxuICAgICAgICBpZiAoaXNJbnB1dFZhbHVlQ2hhbmdlZCkge1xuICAgICAgICAgIF90aGlzLnNldElucHV0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5wdXRWYWx1ZUNoYW5nZWQgJiYgaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbkNoYW5nZSkpIHtcbiAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25CbHVyKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkJsdXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gdGlueSB1bmludGVudGlvbmFsIG1vdXNlIG1vdmVtZW50cyBjYW4gYnJlYWsgY3Vyc29yXG4gICAgICAvLyBwb3NpdGlvbiBvbiBmb2N1cywgc28gd2UgaGF2ZSB0byByZXN0b3JlIGl0IGluIHRoYXQgY2FzZVxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzEwOFxuICAgICAgaWYgKCFfdGhpcy5mb2N1c2VkICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgX3RoaXMubW91c2VEb3duWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIF90aGlzLm1vdXNlRG93blkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICBfdGhpcy5tb3VzZURvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24gbW91c2VVcEhhbmRsZXIobW91c2VVcEV2ZW50KSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcblxuICAgICAgICAgIGlmICghX3RoaXMuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkZWx0YVggPSBNYXRoLmFicyhtb3VzZVVwRXZlbnQuY2xpZW50WCAtIF90aGlzLm1vdXNlRG93blgpO1xuICAgICAgICAgIHZhciBkZWx0YVkgPSBNYXRoLmFicyhtb3VzZVVwRXZlbnQuY2xpZW50WSAtIF90aGlzLm1vdXNlRG93blkpO1xuICAgICAgICAgIHZhciBheGlzRGVsdGEgPSBNYXRoLm1heChkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgICB2YXIgdGltZURlbHRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBfdGhpcy5tb3VzZURvd25UaW1lO1xuXG4gICAgICAgICAgaWYgKGF4aXNEZWx0YSA8PSAxMCAmJiB0aW1lRGVsdGEgPD0gMjAwIHx8IGF4aXNEZWx0YSA8PSA1ICYmIHRpbWVEZWx0YSA8PSAzMDApIHtcbiAgICAgICAgICAgIF90aGlzLnNldEN1cnNvclRvRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uTW91c2VEb3duKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbk1vdXNlRG93bihldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uUGFzdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uUGFzdGUpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uUGFzdGUoZXZlbnQpO1xuICAgICAgfSAvLyBldmVudC5jbGlwYm9hcmREYXRhIG1pZ2h0IG5vdCB3b3JrIGluIEFuZHJvaWQgYnJvd3NlclxuICAgICAgLy8gY2xlYW5pbmcgaW5wdXQgdG8gZ2V0IHJhdyB0ZXh0IGluc2lkZSBvbkNoYW5nZSBoYW5kbGVyXG5cblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIF90aGlzLmJlZm9yZVBhc3RlU3RhdGUgPSB7XG4gICAgICAgICAgdmFsdWU6IF90aGlzLmdldElucHV0VmFsdWUoKSxcbiAgICAgICAgICBzZWxlY3Rpb246IF90aGlzLmdldFNlbGVjdGlvbigpXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuc2V0SW5wdXRWYWx1ZSgnJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZVJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIGlzRnVuY3Rpb24oX3RoaXMucHJvcHMuaW5wdXRSZWYpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLmlucHV0UmVmKHJlZik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFzayA9IHByb3BzLm1hc2ssXG4gICAgICAgIF9tYXNrQ2hhciA9IHByb3BzLm1hc2tDaGFyLFxuICAgICAgICBfZm9ybWF0Q2hhcnMgPSBwcm9wcy5mb3JtYXRDaGFycyxcbiAgICAgICAgX2Fsd2F5c1Nob3dNYXNrID0gcHJvcHMuYWx3YXlzU2hvd01hc2ssXG4gICAgICAgIF9iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IHByb3BzLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIF92YWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIF90aGlzLm1hc2tPcHRpb25zID0gcGFyc2VNYXNrKF9tYXNrLCBfbWFza0NoYXIsIF9mb3JtYXRDaGFycyk7XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgX3ZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfbmV3VmFsdWUgPSBnZXRTdHJpbmdWYWx1ZShfdmFsdWUpO1xuXG4gICAgaWYgKF90aGlzLm1hc2tPcHRpb25zLm1hc2sgJiYgKF9hbHdheXNTaG93TWFzayB8fCBfbmV3VmFsdWUpKSB7XG4gICAgICBfbmV3VmFsdWUgPSBmb3JtYXRWYWx1ZShfdGhpcy5tYXNrT3B0aW9ucywgX25ld1ZhbHVlKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oX2JlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIG9sZFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZShvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBfYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2Uoe1xuICAgICAgICAgIHZhbHVlOiBfbmV3VmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB2YWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgIH0sIG51bGwsIF90aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnKCkpO1xuXG4gICAgICAgIF9uZXdWYWx1ZSA9IG1vZGlmaWVkVmFsdWUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMudmFsdWUgPSBfbmV3VmFsdWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElucHV0RWxlbWVudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gdHJ1ZTsgLy8gd29ya2Fyb3VuZCBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzE0N1xuXG4gICAgaWYgKCF0aGlzLmdldElucHV0RE9NTm9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1dpbmRvd3NQaG9uZUJyb3dzZXIgPSBpc1dpbmRvd3NQaG9uZUJyb3dzZXIoKTtcblxuICAgIGlmICh0aGlzLm1hc2tPcHRpb25zLm1hc2sgJiYgdGhpcy5nZXRJbnB1dFZhbHVlKCkgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLnByZXZpb3VzU2VsZWN0aW9uO1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gX3RoaXMkcHJvcHMuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UsXG4gICAgICAgIGFsd2F5c1Nob3dNYXNrID0gX3RoaXMkcHJvcHMuYWx3YXlzU2hvd01hc2ssXG4gICAgICAgIG1hc2sgPSBfdGhpcyRwcm9wcy5tYXNrLFxuICAgICAgICBtYXNrQ2hhciA9IF90aGlzJHByb3BzLm1hc2tDaGFyLFxuICAgICAgICBmb3JtYXRDaGFycyA9IF90aGlzJHByb3BzLmZvcm1hdENoYXJzO1xuICAgIHZhciBwcmV2aW91c01hc2tPcHRpb25zID0gdGhpcy5tYXNrT3B0aW9ucztcbiAgICB2YXIgc2hvd0VtcHR5ID0gYWx3YXlzU2hvd01hc2sgfHwgdGhpcy5pc0ZvY3VzZWQoKTtcbiAgICB2YXIgaGFzVmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlICE9IG51bGw7XG4gICAgdmFyIG5ld1ZhbHVlID0gaGFzVmFsdWUgPyBnZXRTdHJpbmdWYWx1ZSh0aGlzLnByb3BzLnZhbHVlKSA6IHRoaXMudmFsdWU7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gcHJldmlvdXNTZWxlY3Rpb24gPyBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCA6IG51bGw7XG4gICAgdGhpcy5tYXNrT3B0aW9ucyA9IHBhcnNlTWFzayhtYXNrLCBtYXNrQ2hhciwgZm9ybWF0Q2hhcnMpO1xuXG4gICAgaWYgKCF0aGlzLm1hc2tPcHRpb25zLm1hc2spIHtcbiAgICAgIGlmIChwcmV2aW91c01hc2tPcHRpb25zLm1hc2spIHtcbiAgICAgICAgdGhpcy5zdG9wU2F2ZVNlbGVjdGlvbkxvb3AoKTsgLy8gcmVuZGVyIGRlcGVuZHMgb24gdGhpcy5tYXNrT3B0aW9ucyBhbmQgdGhpcy52YWx1ZSxcbiAgICAgICAgLy8gY2FsbCBmb3JjZVVwZGF0ZSB0byBrZWVwIGl0IGluIHN5bmNcblxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKCFwcmV2aW91c01hc2tPcHRpb25zLm1hc2sgJiYgdGhpcy5pc0ZvY3VzZWQoKSkge1xuICAgICAgdGhpcy5ydW5TYXZlU2VsZWN0aW9uTG9vcCgpO1xuICAgIH1cblxuICAgIHZhciBpc01hc2tDaGFuZ2VkID0gdGhpcy5tYXNrT3B0aW9ucy5tYXNrICYmIHRoaXMubWFza09wdGlvbnMubWFzayAhPT0gcHJldmlvdXNNYXNrT3B0aW9ucy5tYXNrO1xuXG4gICAgaWYgKCFwcmV2aW91c01hc2tPcHRpb25zLm1hc2sgJiYgIWhhc1ZhbHVlKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMuZ2V0SW5wdXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc01hc2tDaGFuZ2VkIHx8IHRoaXMubWFza09wdGlvbnMubWFzayAmJiAobmV3VmFsdWUgfHwgc2hvd0VtcHR5KSkge1xuICAgICAgbmV3VmFsdWUgPSBmb3JtYXRWYWx1ZSh0aGlzLm1hc2tPcHRpb25zLCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFza0NoYW5nZWQpIHtcbiAgICAgIHZhciBmaWxsZWRMZW5ndGggPSBnZXRGaWxsZWRMZW5ndGgodGhpcy5tYXNrT3B0aW9ucywgbmV3VmFsdWUpO1xuXG4gICAgICBpZiAoY3Vyc29yUG9zaXRpb24gPT09IG51bGwgfHwgZmlsbGVkTGVuZ3RoIDwgY3Vyc29yUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGlzRmlsbGVkKHRoaXMubWFza09wdGlvbnMsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gZmlsbGVkTGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKHRoaXMubWFza09wdGlvbnMsIGZpbGxlZExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXNrT3B0aW9ucy5tYXNrICYmIGlzRW1wdHkodGhpcy5tYXNrT3B0aW9ucywgbmV3VmFsdWUpICYmICFzaG93RW1wdHkgJiYgKCFoYXNWYWx1ZSB8fCAhdGhpcy5wcm9wcy52YWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBjdXJzb3JQb3NpdGlvbixcbiAgICAgIGVuZDogY3Vyc29yUG9zaXRpb25cbiAgICB9O1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UpKSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnByZXZpb3VzU2VsZWN0aW9uXG4gICAgICB9LCBudWxsLCB0aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnKCkpO1xuICAgICAgbmV3VmFsdWUgPSBtb2RpZmllZFZhbHVlLnZhbHVlO1xuICAgICAgbmV3U2VsZWN0aW9uID0gbW9kaWZpZWRWYWx1ZS5zZWxlY3Rpb247XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHZhciBpc1ZhbHVlQ2hhbmdlZCA9IHRoaXMuZ2V0SW5wdXRWYWx1ZSgpICE9PSB0aGlzLnZhbHVlOyAvLyByZW5kZXIgZGVwZW5kcyBvbiB0aGlzLm1hc2tPcHRpb25zIGFuZCB0aGlzLnZhbHVlLFxuICAgIC8vIGNhbGwgZm9yY2VVcGRhdGUgdG8ga2VlcCBpdCBpbiBzeW5jXG5cbiAgICBpZiAoaXNWYWx1ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGlzTWFza0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBpZiAobmV3U2VsZWN0aW9uLnN0YXJ0ICE9IG51bGwgJiYgbmV3U2VsZWN0aW9uLmVuZCAhPSBudWxsKSB7XG4gICAgICBpc1NlbGVjdGlvbkNoYW5nZWQgPSAhcHJldmlvdXNTZWxlY3Rpb24gfHwgcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgIT09IG5ld1NlbGVjdGlvbi5zdGFydCB8fCBwcmV2aW91c1NlbGVjdGlvbi5lbmQgIT09IG5ld1NlbGVjdGlvbi5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlZCB8fCBpc1ZhbHVlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uLnN0YXJ0LCBuZXdTZWxlY3Rpb24uZW5kKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25EZWZlcklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxEZWZlcih0aGlzLnNlbGVjdGlvbkRlZmVySWQpO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcFNhdmVTZWxlY3Rpb25Mb29wKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbWFzayA9IF90aGlzJHByb3BzMi5tYXNrLFxuICAgICAgICBhbHdheXNTaG93TWFzayA9IF90aGlzJHByb3BzMi5hbHdheXNTaG93TWFzayxcbiAgICAgICAgbWFza0NoYXIgPSBfdGhpcyRwcm9wczIubWFza0NoYXIsXG4gICAgICAgIGZvcm1hdENoYXJzID0gX3RoaXMkcHJvcHMyLmZvcm1hdENoYXJzLFxuICAgICAgICBpbnB1dFJlZiA9IF90aGlzJHByb3BzMi5pbnB1dFJlZixcbiAgICAgICAgYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBfdGhpcyRwcm9wczIuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIFtcIm1hc2tcIiwgXCJhbHdheXNTaG93TWFza1wiLCBcIm1hc2tDaGFyXCIsIFwiZm9ybWF0Q2hhcnNcIiwgXCJpbnB1dFJlZlwiLCBcImJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlXCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gICAgdmFyIGlucHV0RWxlbWVudDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCAvLyBwYXJzZSBtYXNrIHRvIHRlc3QgYWdhaW5zdCBhY3R1YWwgbWFzayBwcm9wIGFzIHRoaXMubWFza09wdGlvbnNcbiAgICAvLyB3aWxsIGJlIHVwZGF0ZWQgbGF0ZXIgaW4gY29tcG9uZW50RGlkVXBkYXRlXG4gICAgIXJlc3RQcm9wcy5tYXhMZW5ndGggfHwgIXBhcnNlTWFzayhtYXNrLCBtYXNrQ2hhciwgZm9ybWF0Q2hhcnMpLm1hc2ssICdyZWFjdC1pbnB1dC1tYXNrOiBtYXhMZW5ndGggcHJvcGVydHkgc2hvdWxkblxcJ3QgYmUgcGFzc2VkIHRvIHRoZSBtYXNrZWQgaW5wdXQuIEl0IGJyZWFrcyBtYXNraW5nIGFuZCB1bm5lY2Vzc2FyeSBiZWNhdXNlIGxlbmd0aCBpcyBsaW1pdGVkIGJ5IHRoZSBtYXNrIGxlbmd0aC4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgIWlzRnVuY3Rpb24oY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAncmVhY3QtaW5wdXQtbWFzazogY2hpbGRyZW4gbXVzdCBiZSBhIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGNvbnRyb2xsZWRQcm9wcyA9IFsnb25DaGFuZ2UnLCAnb25QYXN0ZScsICdvbk1vdXNlRG93bicsICdvbkZvY3VzJywgJ29uQmx1cicsICd2YWx1ZScsICdkaXNhYmxlZCcsICdyZWFkT25seSddO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Qcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0UHJvcHMpO1xuXG4gICAgICBjb250cm9sbGVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcElkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgY2hpbGRyZW5Qcm9wc1twcm9wSWRdO1xuICAgICAgfSk7XG4gICAgICBpbnB1dEVsZW1lbnQgPSBjaGlsZHJlbihjaGlsZHJlblByb3BzKTtcbiAgICAgIHZhciBjb25mbGljdFByb3BzID0gY29udHJvbGxlZFByb3BzLmZpbHRlcihmdW5jdGlvbiAocHJvcElkKSB7XG4gICAgICAgIHJldHVybiBpbnB1dEVsZW1lbnQucHJvcHNbcHJvcElkXSAhPSBudWxsICYmIGlucHV0RWxlbWVudC5wcm9wc1twcm9wSWRdICE9PSByZXN0UHJvcHNbcHJvcElkXTtcbiAgICAgIH0pO1xuICAgICAgISFjb25mbGljdFByb3BzLmxlbmd0aCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJyZWFjdC1pbnB1dC1tYXNrOiB0aGUgZm9sbG93aW5nIHByb3BzIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHJlYWN0LWlucHV0LW1hc2sncyBjb21wb25lbnQgYW5kIHNob3VsZCBub3QgYmUgYWx0ZXJlZCBpbiBjaGlsZHJlbidzIGZ1bmN0aW9uOiBcIiArIGNvbmZsaWN0UHJvcHMuam9pbignLCAnKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghaW5wdXRSZWYsICdyZWFjdC1pbnB1dC1tYXNrOiBpbnB1dFJlZiBpcyBpZ25vcmVkIHdoZW4gY2hpbGRyZW4gaXMgcGFzc2VkLCBhdHRhY2ggcmVmIHRvIHRoZSBjaGlsZHJlbiBpbnN0ZWFkJykgOiB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0RWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlZjogdGhpcy5oYW5kbGVSZWZcbiAgICAgIH0sIHJlc3RQcm9wcykpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkUHJvcHMgPSB7XG4gICAgICBvbkZvY3VzOiB0aGlzLm9uRm9jdXMsXG4gICAgICBvbkJsdXI6IHRoaXMub25CbHVyXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm1hc2tPcHRpb25zLm1hc2spIHtcbiAgICAgIGlmICghcmVzdFByb3BzLmRpc2FibGVkICYmICFyZXN0UHJvcHMucmVhZE9ubHkpIHtcbiAgICAgICAgY2hhbmdlZFByb3BzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZTtcbiAgICAgICAgY2hhbmdlZFByb3BzLm9uUGFzdGUgPSB0aGlzLm9uUGFzdGU7XG4gICAgICAgIGNoYW5nZWRQcm9wcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd247XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN0UHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VkUHJvcHMudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0RWxlbWVudCA9IFJlYWN0LmNsb25lRWxlbWVudChpbnB1dEVsZW1lbnQsIGNoYW5nZWRQcm9wcyk7XG4gICAgcmV0dXJuIGlucHV0RWxlbWVudDtcbiAgfTtcblxuICByZXR1cm4gSW5wdXRFbGVtZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0RWxlbWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgX19ERVZfXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKF9fREVWX18pIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDEgPyBsZW4gLSAxIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMTsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAxXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cblxuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KG51bGwsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4iXSwic291cmNlUm9vdCI6IiJ9